https://opentutorials.org/course/1223
https://wikidocs.net/281

https://www.compilejava.net/

https://limesparkling.tistory.com/17
공부방법: 객제지향 완벽 이해 -> object string,stringbuffer 공부
        ->컬렉션 프레임 웍 완벽 이해 -> 입출력 공부 ->(선택)안드로이드 공부 할거면 AWT/Thread 공부
    
현재 값 호출 이후로부터 공부하면 됨.

생활코딩, 점프 투 자바로
메소드 공부 후 객체지향프로그램 공부할 것

그 후 컬렉션 프레임 웍 공부할 것

마무리로 입출력 공부할 것

그 외 나머지 영역은 필요에 따라 공부....

현재 공부 상황: 클래스,객체,필드,메서드,this 등을 공부했다.


메서드-

class 클래스명 {
    데이터타입 필드명; // 필드명: 클래스의 필드

    // 인스턴스 메서드: 필드에 값을 설정
    public void 메서드이름(데이터타입 필드명) { // "메서드이름(데이터타입 필드명)"가 메서드다.

    메서드 이름은 setName을 추천하며
    (데이터타입 필드명)에서 필드명이 매개변수다.

        this.필드명 = 필드명; 
    
    this는 객체를 가리키며 객체의 필드와 메서드 참조하게 만듦
    this.필드명:클래스의 필드를 가리키며 객체의 속성에 접근할 때 사용
    필드명: 클래스의 속성을 나타내는 변수 객체 특성 저장
    }

    // 인스턴스 메서드: 필드 값을 반환
    public 데이터타입 메서드이름() { //getField 추천
        return 필드명; // 필드 반환
    }

    public static void main(String[] args) {
        클래스명 객체 = new 클래스명(); // 객체 생성
        객체.setField(값); // 필드에 값 할당 (값을 실제 데이터로 변경)
        System.out.println(객체.getField()); // 필드 값 출력
    }
}

-------------------------------------------------------------
class Person {
    String name; // 필드

    // 인스턴스 메서드: 필드에 값을 설정
    public void setName(String name) {
        this.name = name; // 필드에 매개변수 할당
    }

    // 인스턴스 메서드: 필드 값을 반환
    public String getName() {
        return name; // 필드 반환
    }

    public static void main(String[] args) {
        Person person = new Person(); // 객체 생성
        person.setName("Alice"); // 필드에 값 할당
        System.out.println(person.getName()); // 필드 값 출력 (출력: Alice)
    }
}

-----------------------------------------------------------------------------
자바 객체지향프로그래밍 메서드 과정

this.name = name;은 매개변수 값을 name 필드에 복사하는 작업입니다.
person.setName("Alice"); 호출로 인해 "Alice"가 매개변수 name에 전달되며, 
이후에 이 값이 person 객체의 name 필드에 저장됩니다.

1.setName(String name)이라는 메서드를 만들어서 구조를 획일화, 변수값을 직접 설정을 막음.
2.this.name = name;으로 매개변수값을 변수/필드에 할당함.
3.person.setName("Alice");는 메서드 호출로 setName메서드에 있는 name에 Alice라는 값을 전달함.
그리고 그 전달값을 변수/필드값에 할당함.

4.그렇게 매개변수값에 Alice값이 변수/필드에 값으로 할당이 되었고 
그 뒤 System.out.println(person.getName());으로 필드값을 출력함.

드디어 이해한듯..

그 외에 메서드----------------------
return 사용법:

public class Sample {
    void sayNick(String nick) {
        if ("바보".equals(nick)) {
            return;
        }
        System.out.println("나의 별명은 "+nick+" 입니다.");
    }

    public static void main(String[] args) {
        Sample sample = new Sample();
        sample.sayNick("야호");
        sample.sayNick("바보");  // 출력되지 않는다.
    }
}

return;으로 하게 된다면, 바보가 출력되지 않는다.

메서드 내 변수 효력 범위-------------------------
public class Sample {
    void varTest(int a) {
        a++;
    }

    public static void main(String[] args) {
        int a = 1;
        Sample sample = new Sample();
        sample.varTest(a);
        System.out.println(a);
    }
}

1. main메서드에서 a에 1을 대입함.
2. varTest메서드를 입력해서 a를 주어 호출?
3.a의 값을 출력

2가 아닌 1이 출력된 이유는

void varTest(int a) {
        a++;
}

해당 메서드가 메서드 안에서만 쓰이기에 다른 메서드의 값에 영향을 주지 않는다.

그렇다면 다른 메서드의 값에 영향을 주는 경우는 총 2가지로

1.
a = sample.varTest(a);로 호출시키면 된다.

2.
sample.a++;
sample.a=1;로 변수a를 sample클래스의 객체 변수로 선언해서 해당 객체를 1만큼 증가시키고
main 메서드에서 varTest메서드를 호출하면 Sample 클래스의 sample을 전달하도록 수정했다.



값에 의한 호출---------------
class Updater {
    void update(Counter counter) { //int count
        counter.count++; //count++;
    }
}

class Counter {
    int count = 0;
}

public class Sample {
    public static void main(String[] args) {
        Counter myCounter = new Counter();
        System.out.println("before update:"+myCounter.count);
        Updater myUpdater = new Updater();
        myUpdater.update(myCounter);
        System.out.println("after update:"+myCounter.count);
    }
}

설명: 
int count = count(count++)이라고 가정해보자.

1. 오른쪽 count++이 값을 복사한다. 이때 값이0이면 0을 복사하고,
++을 하므로 복사된 값은 1로 증가한다.

2. 그러나 1로 증가한 값을 전달하는게 아닌 0을 우선적으로 전달하기에 
count(++)로 0을 복사하고 왼쪽 int count에 0을 전달하고 count(++)이 0에서 1로 복사한 값이 증가한다.

결론: 최종적으로 count++이 0을 복사하여 왼쪽의 int count에 0이 전달되고, 
오른쪽의 count는 그 이후 0에서 1로 증가된 것이다.

상속----------------------------
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal { //Animal에 있는 클래스를 Dog 클래스에 그대로 사용하게 만듦.
                          // + 만약 상속을 사용하지 않는다면 Dog 클래스와 필드 메소드를 다시 만들어야 함.
    void sleep() {
        System.out.println(this.name+" zzz");
    }
}

public class Sample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.setName("poppy");
        System.out.println(dog.name);
        dog.sleep();
    }
}

해석: 
dog.setName("poppy")는 Animal 클래스에서 상속받은 setName 메서드를 호출합니다.
이 메서드가 호출되면, this.name = "poppy"로 설정됩니다.
여기서 **this.name**은 Dog 클래스가 상속받은 Animal 클래스의 name 필드를 의미합니다.
따라서 dog 객체의 name 필드에 "poppy"가 저장됩니다.


메서드 오버라이징 및 상속--------------------------------------
class Dog {
    void sleep() {
        System.out.println("강아지가 잠을 잡니다.");
    }
}

class HouseDog extends Dog {
    // sleep() 오버라이딩을 하지 않음
}

public class Sample {
    public static void main(String[] args) {
        HouseDog houseDog = new HouseDog();
        houseDog.sleep();  // "강아지가 잠을 잡니다." 출력
    }
}

Dog 클래스에서 sleep()으로 메서드를 만든 상태다.
그리고 class Dog extends Animal {으로 Animal클래스에 있는걸 Dog 클래스에 그대로 이용할 수 있게 "상속"을 사용하였다.
그렇기에 현재 Dog클래스에서 HouseDog클래스로 sleep()매서드가 옮겨진 상태이며,
HouseDog클래스에서 sleep()매서드를 자기자신만의 방식으로 다시 정의하는 방식이 오버라이징인 상태인것이다.

생성자-------------------------------------------------------------------------------------
음 애매한듯? 이해한건지 잘 모르겄음 일단 pass

인터페이스---------------------------------------------------------------------------------

어려움(hard)

인터페이스란 쉽게 말해서 메서드를 중복해서 만들 수 있게 짜는 것이다.

class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Tiger extends Animal {
}

class Lion extends Animal {
}

class ZooKeeper {
    void feed(Tiger tiger) {  // 호랑이가 오면 사과를 던져 준다.
        System.out.println("feed apple");
    }

    void feed(Lion lion) {  // 사자가 오면 바나나를 던져준다.
        System.out.println("feed banana");
    }
}

이 코드를 보면 현재 Animal 클래스를 만들고 상속으로 Tiger와 Lion을 서로 연동시키고
ZooKeeper 클래스에서 ???가 오면 ??를 던져 준다.를 지속적으로 출력하고 있다.
그러나, 만약 호랑이,사자,토끼를 비롯해서 수만마리를 출력해야한다면 

void feed(?? ??) {  // ??가 오면 바나나를 던져준다.
        System.out.println("feed banana");
    }
}
코드에 ?? ??를 수만개를 만들어서 출력해야하는가? 이를 중복해서 코드를 효율적으로 짜 주는 것이 인터페이스이다.

인터페이스 완성 코드를 보자면,

interface Predator {
    String getFood();

    default void printFood() {
        System.out.println("my food is " + getFood());
    }
}

class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Tiger extends Animal implements Predator {
    public String getFood() {
        return "apple";
    }
}

class Lion extends Animal implements Predator {
    public String getFood() {
        return "banana";
    }
}

class ZooKeeper {
    public void feed(Predator predator) {
        System.out.println("feed " + predator.getFood());
    }
}

여기서 
