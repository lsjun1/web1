https://opentutorials.org/course/1223
https://wikidocs.net/281

https://www.compilejava.net/

생활코딩, 점프 투 자바로
메소드 공부 후 객체지향프로그램 공부할 것

그 후 컬렉션 프레임 웍 공부할 것

마무리로 입출력 공부할 것

그 외 나머지 영역은 필요에 따라 공부....

현재 공부 상황: 클래스,객체,필드,메서드,this 등을 공부했다.


메서드-

class 클래스명 {
    데이터타입 필드명; // 필드명: 클래스의 필드

    // 인스턴스 메서드: 필드에 값을 설정
    public void 메서드이름(데이터타입 필드명) { // "메서드이름(데이터타입 필드명)"가 메서드다.

    메서드 이름은 setName을 추천하며
    (데이터타입 필드명)에서 필드명이 매개변수다.

        this.필드명 = 필드명; 
    
    this는 객체를 가리키며 객체의 필드와 메서드 참조하게 만듦
    this.필드명:클래스의 필드를 가리키며 객체의 속성에 접근할 때 사용
    필드명: 클래스의 속성을 나타내는 변수 객체 특성 저장
    }

    // 인스턴스 메서드: 필드 값을 반환
    public 데이터타입 메서드이름() { //getField 추천
        return 필드명; // 필드 반환
    }

    public static void main(String[] args) {
        클래스명 객체 = new 클래스명(); // 객체 생성
        객체.setField(값); // 필드에 값 할당 (값을 실제 데이터로 변경)
        System.out.println(객체.getField()); // 필드 값 출력
    }
}

-------------------------------------------------------------
class Person {
    String name; // 필드

    // 인스턴스 메서드: 필드에 값을 설정
    public void setName(String name) {
        this.name = name; // 필드에 매개변수 할당
    }

    // 인스턴스 메서드: 필드 값을 반환
    public String getName() {
        return name; // 필드 반환
    }

    public static void main(String[] args) {
        Person person = new Person(); // 객체 생성
        person.setName("Alice"); // 필드에 값 할당
        System.out.println(person.getName()); // 필드 값 출력 (출력: Alice)
    }
}

-----------------------------------------------------------------------------
자바 객체지향프로그래밍 의식의 흐름


class 클래스명 { // c언어로 치자면 struct void main같은거고 구조를 효율적으로 압축하기 위해 만듬
    데이터타입 필드명; // 원하는 구조에 구조 속 데이터타입이 어떤지 구조에서 정확히 어떤 걸 원하는지 필드명으로 구체화함.

    public void 메서드이름(데이터타입 필드명) { //메서드이름으로 현재 이 코드가 어떤 역할을 하는지 알려주고 (데이터타입 필드명)을 넣어서 클래스와 연동시킴(데이터타입과 필드명을 연동시킴)
    this.필드명 = 필드명; 

    this는 객체를 가리키며 객체의 필드(데이터타입 필드명)에서 (필드명)과 메서드를 연동시킴
    this.필드명:클래스의 필드를 가리키며 객체의 속성에 접근할 때 사용
    필드명: 클래스의 속성을 나타내는 변수 객체 특성 저장

    즉 this로 (필드명)과 public void 메서드이름이라고 불리는 구조를 서로 연동시킴
    this.필드명으로 객체의 속성에 접근?
    "this.필드명 = 필드명"에서 필드명" class 클래스 명 { 속 객체의 속성 즉 클래스명 객체 = new 클래스명();를 가리킴?
    필드명: class 속 객체를 저장(클래스명 객체 = new 클래스명();)

     public 데이터타입 메서드이름() { //메서드이름은 getField를 추천함
            return 필드명; //걍 필드명을 출력함(근데 public void로 출력하지만 결과는 나타내지는 않는?
      }

        public static void main(String[] args) { 
            클래스명 객체 = new 클래스명();
            클래스명은 걍 클래스명이고 객체도 걍 변수고 근데 new 클래스명()으로 객체를 생성함.
        객체.setField(값); 객체.메서드이름(값); 원하는 결과물을 (값)에다가 넣고
        객체.메서드이름();이라는 구조로 객체와 메서드이름을 연동시켜 값을 출력시키기 위한 토대를 마련함
        System.out.println(객체.메서드명()); 토대를 마련한걸 출력하기 위한 결과임.

값에 의한 호출---------------
class Updater {
    void update(Counter counter) { //int count
        counter.count++; //count++;
    }
}

class Counter {
    int count = 0;
}

public class Sample {
    public static void main(String[] args) {
        Counter myCounter = new Counter();
        System.out.println("before update:"+myCounter.count);
        Updater myUpdater = new Updater();
        myUpdater.update(myCounter);
        System.out.println("afater update:"+myCounter.count);
    }
}

설명: 
int count = count(count++)이라고 가정해보자.

1. 오른쪽 count++이 값을 복사한다. 이때 값이0이면 0을 복사하고,
++을 하므로 복사된 값은 1로 증가한다.

2. 그러나 1로 증가한 값을 전달하는게 아닌 0을 우선적으로 전달하기에 
count(++)로 0을 복사하고 왼쪽 int count에 0을 전달하고 count(++)이 0에서 1로 복사한 값이 증가한다.

결론: 최종적으로 count++이 0을 복사하여 왼쪽의 int count에 0이 전달되고, 
오른쪽의 count는 그 이후 0에서 1로 증가된 것이다.
