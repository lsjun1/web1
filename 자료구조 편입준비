요약:
동적할당의 개념
동적할당의 문제점과 해결책

힙의 개념
힙

인천대

동적할당,힙,힙소트 시간 복잡도,힙 적용한거 뭐 있냐,자료구조 유의할 점,파이썬 문제 하나
동적할당시 발생할 수 있는 문제점과 해결책

동적할당이란?
필요한 메모리 공간을 힙 영역에서 할당하는 것입니다.
구조체 같은 데이터를 저장할려면 공간할당하고 사용 끝에는 free()나 delete로 메모리 해제해야합니다.

동적할당의 문제점과 해결책

메모리 누수,잘못된 메모리 접근, 버퍼 오버플로우, 이중 해제가 있습니다.

1.메모리 누수 
메모리 누수를 방지하기 위해 free()로 호출하면 됩니다.

2.잘못된 메모리 접근 
메모리 접근을 올바르게 처리하려면, 할당된 메모리 포인터가 NULL인지 확인하고, 해제 후에는 포인터를 NULL로 설정하여 잘못된 접근을 방지할 수 있습니다.
만약 메모리 할당이 실패한 경우, 할당된 메모리를 제대로 확인하지 않고 접근하면 세그멘테이션 폴트가 발생할 수 있으므로, 
항상 할당 후에 NULL 여부를 체크해야 합니다

3.버퍼 오버플로우 
버퍼 오버플로우를 방지하기 위해 메모리 크기를 정확히 계산해야하니 안전한 함수로 버퍼크기를
초과해야하지 않도록 합니다.

4.이중 해제 
이중 해제를 방지하기 위해 메모리를 해제한 후 포인터를 NULL로 설정하여 재해제를 방지해야 합니다.

힙은 완전 트리의 일종으로 우선순위 큐를 구현하는데 사용되는 자료 구조입니다.

힙은 우선순위 큐,힙 정렬,다익스트라 알고리즘등에 사용됩니다.

우선순위 큐는 각 원소가 우선순위를 가지고 있으며 가장 높은 우선순위의 원소를 빠르게 추출할 수 있게 합니다.
힙을 사용하면 삽입 삭제는 O(log n)시간에 이루어집니다.

힙 정렬은 힙에서 최대값 또는 최솟값을 반복 추출하여 배열을 정렬하며
시간 복잡도는 O(n long n)입니다.

다익스트라 알고리즘은 최단 경로 알고리즘이며 가장 적은 비용을 가진 노드를 빠르게 추출가능합니다.
우선순위 큐를 구현하기 위해 힙이 사용됩니다.

자료구조 유의할 점
효율성 적합성 메모리 관리

배열은 인덱스를 통한 빠른 접근이 가능하지만
삽입 삭제는 비효율적입니다.
반면 링크드 리스트는 삽입 삭제가 빠르지만 인덱스를 통한 접근이 느립니다.
이러한 관계를 알고 효율성을 파악하는게 중요합니다.

탐색이 중요한 경우 이진 탐색  트리, 해시 테이블이 적합하며
최단 경로를 구해야 한다면 그래프와 힙을 활용해야합니다.

이 처럼 상황에 따라 적합한 자료 구조를 선택해야합니다.

동적 할당을 하는 구조에서는 메모리 관리를 신경 써야 합니다.
메모리 누수나 이중 해제 같은 문제가 발생하지 않도록 주의해야합니다.
malloc()과 free()를 사용할 때 할당된 메모리를 반드시 해제하고 포인터를 NULL로 설정해서
잘못된 접근을 방지해야합니다.


충북대

자율주행,5g관련 이슈

o(1)복잡도 가지는 정렬 알고리즘이 뭐 있냐?
아무리 정렬된 테이블이여도 버블 솔트같은 경우는 o(n)으로도 동작하는데...

정렬 알고리즘에서 시간 복잡도는 최소 o(n long n)이상의 시간이 걸리며
정렬된 경우 한정으로 시간복잡도를 가질 수는 있지만 이론적으로는 불가능합니다.

연결리스트 추가방식 c
->새노드가 추가될 때 어떤식으로 노드가 생성되는지 궁금해 하신듯?

연결 리스트에서 새 노드를 추가하는 방식은 세 가지로 나눌 수 있습니다.

머리에 추가 
새 노드를 첫 번째 노드로 추가하는 방식입니다.

새 노드를 생성한 후, 새 노드의 next를 기존 머리 노드로 가리키게 하고, 
머리 포인터를 새 노드를 가리키도록 업데이트합니다. 
이렇게 하면 새 노드가 리스트의 첫 번째 노드가 됩니다.

끝에 추가
새 노드를 리스트의 마지막에 추가하는 방식입니다.

리스트 끝까지 이동한 후, 마지막 노드의 next를 새 노드를 가리키게 합니다. 
리스트가 비어 있으면 새 노드를 머리에 추가합니다.

특정 위치에 추가
새 노드를 특정 위치에 추가하는 방식입니다.

지정한 위치까지 이동한 후, 이전 노드의 next를 새 노드를 가리키게 하고, 
새 노드의 next는 다음 노드를 가리키게 합니다.


해시테이블 이용한 탐색에서 발생하는 충돌이 뭐냐

두 개 이상의 키가 동일한 해시값을 가질 때 생긴 문제며
탐색 속도가 느려지고 메모리 낭비가 발생할 수 있습니다.

이에 대한 해결법으로는
체이닝, 열린 주소법, 헤시 테이블 크기 조정 총 3가지가 있습니다.

체이닝
충돌이 발생하면 해당 위치에 연결리스트를 만들어서 모든 요소를 저장합니다.

열린 주소법

충돌 시 다른 빈 위치를 찾아 데이터를 저장합니다.

선형 탐색:충돌이 발생한 인덱스에서 한 칸씩 순차적으로 다음 빈 자리를 찾습니다.

제곱 탐색:충돌이 발생한 인덱스에서 일정한 제곱수만큼 떨어진 곳을 찾아 시도합니다.

이중 해싱:두 번째 해시 함수를 이용하여 충돌을 해결합니다.

해시 테이블 크기 조정

일정 비율로 테이블이 가득 차면 테이블의 크기를 늘리고 데이터를 재배치 합니다.
크기 확장 한다면 해시 함수가 변경되므로 다시 모든 요소를 해시 테이블에 삽입해야합니다.

충돌이 발생한다면

메모리 계층 물어봄

백엔드 흥미 있다고 하니 그거 관련해서 좀 물어봄

한기대
스택 abc 순서 칠판 코딩, 최적 알고리즘 물어봄

최적 알고리즘은 시간과 공간을 효율적으로 사용하는 알고리즘을 의미합니다.
최적 알고리즘의 특징으로는 시간 복잡도 공간 복잡도 효율성 3가지가 있으며



포인터가 뭔지, 가위바위보 했을 때 이길 확률은 몇 분의 몇인지
